\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{textcomp}
\usepackage{newunicodechar}

\geometry{margin=1in}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10}
}

% Unicode character definitions
\newunicodechar{↔}{\ensuremath{\leftrightarrow}}
\newunicodechar{→}{\ensuremath{\rightarrow}}
\newunicodechar{−}{\ensuremath{-}}
\newunicodechar{≈}{\ensuremath{\approx}}
\newunicodechar{•}{\ensuremath{\bullet}}

% Custom commands
\newcommand{\code}[1]{\texttt{#1}}

\title{Compositional Abstractions for ARC-Style Tasks}
\author{}
\date{}

\begin{document}

\maketitle

\section{Abstract}

We study how \textbf{compositional abstractions} shrink program-search for ARC-style grid puzzles by removing symmetries \emph{before} search. We represent an abstraction as \textbf{(G + invariant)}: a concrete grid transformation $G$ together with an \textbf{invariant} that constrains which concrete worlds we consider equivalent. A task is solvable in an abstracted space if: (i) its invariants hold; and (ii) a \textbf{mapping exists} in the abstract space that transfers back to the concrete space via a simple gauge (bookkeeping) map.

Two tiny abstractions suffice to make otherwise messy tasks trivial:
\begin{itemize}
\item \textbf{A1: Palette canonicalization.} Relabel non-zero colors by decreasing frequency. This quotients out palette symmetry so rules like ``least-frequent color'' have a canonical id.
\item \textbf{A2: Canonical object order.} Sort connected components by $(area, top, left, color)$. This quotients out object-enumeration symmetry so rules like ``component index 0'' are stable---even in ties.
\end{itemize}

Empirically, composing \textbf{A1→A2} collapses the search space from thousands of programs to \textbf{two}; both are valid for the studied case, giving \textbf{near-zero search cost}.

\section{Introduction}

\textbf{ARC} tasks operate on small integer grids. Many puzzles involve selecting an object (a connected component), choosing a (target) color, and recoloring. Naively, a solver faces huge \textbf{spurious multiplicity}: many grids differ only by a permutation of color ids or by the order we enumerate objects, yet a human treats them as ``the same.''

Our goal is to \textbf{quotient symmetries away} with minimal machinery, leaving a tiny set of candidate programs that are all semantically distinct. We make three design choices:

\begin{itemize}
\item \textbf{Abstractions as $G +$ invariant.} Each abstraction applies a concrete normalization $G$ (e.g., renaming colors; sorting objects) and comes with an invariant that must hold after normalization.
\item \textbf{Mapping existence before search.} We first check that a simple family of mappings exists in the abstract space; only then do we enumerate candidate programs.
\item \textbf{Microscopic DSLs.} We intentionally use tiny search spaces to show how much the \textbf{symmetry quotient} alone reduces the burden.
\end{itemize}

\section{Running Examples (3 pairs)}

We use small grids where the target action can be stated compactly: \textbf{select a component} $\times$ \textbf{choose a color} $\times$ \textbf{recolor the component} (e.g., ``recolor the smallest component to the least-frequent non-zero color''). Examples include ties (equal-area components) and multi-color scenes so that without a canonical order, phrases like ``the smallest'' are ambiguous.

\section{Abstractions as G + Invariant}

We spell out the two building blocks and how they eliminate symmetry.

\subsection{A1: Palette canonicalization}

$\alpha_1$: relabel non-zero colors by \textbf{decreasing frequency}, breaking ties by the \textbf{smaller original color id}. Background \code{0} is preserved. Returns \code{(x\_hat, meta)} with \code{meta = \{"orig\_for\_can": ..., "can\_for\_orig": ...\}}.

\begin{itemize}
\item \textbf{Invariant.} No forbidding constraints beyond keeping background \code{0} intact.
\item \textbf{Gauge.} A bidirectional palette map (original↔canonical) to transfer predictions back to the original ids.
\item \textbf{Why.} Quotients out \textbf{palette symmetry}, making statements like ``least-frequent color'' well-defined in every instance.
\end{itemize}

\subsection{A2: Canonical object order (on top of A1)}

$\alpha_2$: sort connected components by the tuple $(area, top, left, color)$ after A1.

\begin{itemize}
\item \textbf{Invariant.} Metadata-only; does not constrain geometry beyond the ordering.
\item \textbf{Gauge.} The canonical order list to transfer ``index-based'' references back to concrete component ids.
\item \textbf{Why.} Quotients out \textbf{object-enumeration symmetry} so that ``component index 0'' has a stable meaning even in tie situations.
\end{itemize}

\subsection{Mapping existence (search-free)}

Before enumerating programs, we check that an appropriate \textbf{mapping exists} in the abstract space. For the family we study (select-component $\times$ choose-color $\times$ recolor), existence reduces to:
\begin{enumerate}
\item \textbf{Selectors} can name at least one component under $\alpha_2$ (e.g., \code{index0}, \code{smallest}).
\item \textbf{Color rules} can name a palette element under $\alpha_1$ (e.g., \code{least\_frequent}, \code{most\_frequent}, or fixed ids after canon).
\item \textbf{Gauge transfer} (palette map + order list) can un-canonize the abstract action back to the original grid.
\end{enumerate}

If these checks pass on all training pairs, we proceed to program enumeration; otherwise, we abstain.

\section{Program Search Spaces (DSLs)}

\textbf{Code-coherent identifiers (from \code{arc\_abstraction\_dsl\_2.py}):}
\begin{itemize}
\item A1: \code{alpha1\_palette(x) -> (x\_hat, meta)} where \code{meta = \{"orig\_for\_can": ..., "can\_for\_orig": ...\}}.
\item A2: \code{alpha2\_objorder(x\_hat) -> (x\_hat, \{"order": comps\_sorted\})} with sort key $(area, top, left, color)$.
\item Color rules: \code{COLOR\_RULES = [("max\_id", sel\_color\_max\_id), ("argmin\_hist", sel\_color\_argmin\_hist)]}.
  \begin{itemize}
  \item Under A1, \textbf{both} pick a least-frequent color; when multiple colors tie, both choose the \textbf{largest canonical id}.
  \end{itemize}
\item Selectors:
  \begin{itemize}
  \item Raw/G: \code{sel\_comp\_smallest\_unstable} (hash-shuffled tie-break) \textbf{and} \code{sel\_comp\_smallest\_canonical}.
  \item A1: many variants from \code{build\_A1\_selectors()} (different tie-break keys and seeded shuffles) \textbf{plus} \code{sel\_comp\_smallest\_canonical}.
  \item A1→A2: fixed \code{("index0", lambda a: sel\_comp\_smallest\_canonical(a))}.
  \end{itemize}
\item G pre-ops: \code{build\_preops\_for\_dataset(...)} produces \code{("identity", ...)} and hundreds of \code{"perm\_*"} random palette permutations to explode the search space.
\end{itemize}

These names are what appear in the results and JSON artifacts the script writes.

We use three nested spaces, each reusing the same \textbf{action family} (select component $\times$ choose color $\times$ recolor) but differing in \emph{how many spurious variants} they contain.

\begin{itemize}
\item \textbf{G (raw).} Enumerates many selector variants (by geometry and enumeration) and many color rules that simulate palette symmetry. This intentionally inflates the candidate count.
\item \textbf{A1.} After palette canonicalization, we still allow numerous selector tie-break variants to show that removing palette symmetry alone is incomplete.
\item \textbf{A1→A2.} After canonical object ordering, the DSL collapses to \textbf{two} programs: $\{$color rule$\} \times \{$index0$\}$ (implemented as ``canonical smallest'').
\end{itemize}

Across all spaces, the mapping family is identical; only the \textbf{symmetry multiplicity} changes.

\subsection{Concrete worked examples (aligned with \code{arc\_abstraction\_dsl\_2.py})}

\subsubsection{Concrete example: A1 palette canonicalization}

Original grid (colors: 0=background, 2,3,5):

\begin{lstlisting}
0 0 2 2 0 0
0 3 3 0 0 0
0 3 0 0 5 5
0 0 0 0 5 0
\end{lstlisting}

Non-zero histogram: 3→3, 5→3, 2→2.  
Canonical relabel (descending frequency, ties by \textbf{smaller original id}): 3→1, 5→2, 2→3.

Canonicalized grid \code{x\_hat} and meta:

\begin{lstlisting}
1 1 1 0 0 0
1 1 0 0 2 2
0 0 0 0 0 0
0 0 0 2 2 2
0 0 0 0 0 1
\end{lstlisting}

\code{meta.orig\_for\_can = \{1: 3, 2: 5, 3: 2\}}  
\code{meta.can\_for\_orig = \{3: 1, 5: 2, 2: 3\}}

\subsubsection{Concrete example: A2 canonical object order}

Connected components in \code{x\_hat} above, summarized as $(area, (top,left), color)$:

\begin{itemize}
\item (2, (0, 2), 3)
\item (3, (1, 1), 1)
\item (3, (2, 4), 2)
\end{itemize}

A2 orders them by $(area, top, left, color)$, so \textbf{index 0} is the $(2, (0,2), 3)$ component.

\subsubsection{End-to-end example: A1→A2 + recolor + gauge back}

Input $x$ (original palette):

\begin{lstlisting}
7 7 7 0 0 0
7 7 0 0 2 2
0 0 0 0 0 0
0 0 0 3 3 3
0 0 0 0 0 7
\end{lstlisting}

After A1 canonicalization (\code{x\_hat}):

\begin{lstlisting}
1 1 1 0 0 0
1 1 0 0 3 3
0 0 0 0 0 0
0 0 0 2 2 2
0 0 0 0 0 1
\end{lstlisting}

Selector: \code{sel\_comp\_smallest\_canonical(x\_hat)} → the single-pixel component (area=1).  
Color rule: \code{sel\_color\_argmin\_hist(x\_hat)} → choose the \textbf{least-frequent} canonical color = 3.  
Apply \code{recolor\_component(x\_hat, comp, 3)}:

\begin{lstlisting}
1 1 1 0 0 0
1 1 0 0 3 3
0 0 0 0 0 0
0 0 0 2 2 2
0 0 0 0 0 3
\end{lstlisting}

Gauge back to original palette using \code{meta.orig\_for\_can} (1→7, 2→3, 3→2):

\begin{lstlisting}
7 7 7 0 0 0
7 7 0 0 2 2
0 0 0 0 0 0
0 0 0 3 3 3
0 0 0 0 0 2
\end{lstlisting}

\section{Algorithm (sketch)}

\begin{enumerate}
\item \textbf{Normalize inputs} with $\alpha_1$ then $\alpha_2$; record palette map and order list.
\item \textbf{Validate invariants} on all train pairs.
\item \textbf{Check mapping existence} in the abstract space (selectors $\times$ color rules $\times$ recolor).
\item \textbf{Enumerate candidate programs} in the chosen DSL (G, A1, or A1→A2).
\item \textbf{Evaluate} on train; keep programs consistent with all pairs.
\item \textbf{Transfer} the chosen abstract action back to each concrete grid via the gauges.
\end{enumerate}

This ordering---\textbf{validation → existence → search}---prevents wasted search when symmetry removal already makes the solution unique.

\section{Experimental Protocol}

We evaluate a single ARC-style task family with three DSLs (G, A1, A1→A2). Metrics:
\begin{itemize}
\item \code{total\_candidates} -- size of the enumerated space.
\item \code{num\_valid} -- programs consistent with all training pairs.
\item \code{avg\_tries\_to\_success} -- mean number of attempts until the first valid program is found when sampling uniformly at random.
\item \code{wall\_time\_s} -- runtime for a deterministic sweep on our simple reference implementation.
\end{itemize}

\section{Results}

\textbf{Local-run results (your updated run):}
\begin{lstlisting}
[G]      total_candidates=2404  num_valid=441  avg_tries_to_success=5.405   wall_time_s=3.884
[A1]     total_candidates=172   num_valid=4    avg_tries_to_success=35.573  wall_time_s=0.197
[A1->A2] total_candidates=2     num_valid=2    avg_tries_to_success=1.000   wall_time_s=0.028
\end{lstlisting}

These match the qualitative trend reported earlier (in a single-dataset summary) and sharpen the magnitude of the win from composing A1 with A2.

\subsection{Read-off improvements from the local run}

\begin{itemize}
\item \textbf{Program count shrinks:} G→A1: 2404→172 (\textbf{−92.85\%}); A1→A1→A2: 172→2 (\textbf{−98.84\%}). Overall G→A1→A2: \textbf{−99.917\%} (2404→2).
\item \textbf{Runtime collapses:} 3.884s→0.197s (\textbf{×19.7 faster}), then 0.197s→0.028s (\textbf{×7.0 faster}). Overall: \textbf{×138.7 faster} (3.884s→0.028s).
\item \textbf{Effort to first solution:} \code{avg\_tries\_to\_success} is \textbf{1.0} in A1→A2 (immediate), \textbf{5.41} in G (moderate), and \textbf{35.57} in A1 (smaller space but \textbf{noisier} due to tie-break variants); composition with A2 removes that ambiguity.
\item \textbf{Validity rates:} A1→A2: \textbf{2/2} (100\%); A1: \textbf{4/172 ≈ 2.3\%}; G: \textbf{441/2404 ≈ 18.3\%}.
\end{itemize}

\section{Interpretation}

\begin{itemize}
\item \textbf{A1 (palette canonicalization)} quotients out color symmetry so rules like ``least-frequent color'' become stable; however, it leaves \textbf{object enumeration} ambiguous, hence many decoy selectors and high try counts.
\item \textbf{A2 on top of A1} quotients out object-enumeration symmetry so only the semantically distinct index-based programs remain. Because the DSL is tiny after A1→A2, \textbf{every remaining program is correct} on the studied task, and time-to-solution is near zero.
\end{itemize}

\section{Why A2 is needed (and helpful)}

Ties in geometry (equal-area components, nearby positions) are common in ARC. Without a canonical enumeration, selectors like ``smallest,'' ``top-most,'' or ``first component'' splinter into many arbitrarily-ordered variants. A2 \textbf{chooses one consistent ordering}, eliminating these spurious degrees of freedom and making index-based rules stable across pairs.

\section{Limitations \& Extensions}

\begin{itemize}
\item Our DSL is intentionally tiny; we focused on the symmetry quotient effects, not on broad coverage of ARC.
\item A1's ordering rule (frequency → first occurrence) is one of many possible canonicalizations; other tasks may require different tie-breaks.
\item The mapping-existence step is specialized to \textbf{select×color×recolor}. Richer action families (e.g., geometric rewrites) would need their own existence checks and gauges.
\item Extensions: add shape-level canonicalizations (e.g., rotation/flip quotient), object-relation canonicalizations, and richer color policies while preserving the \textbf{validate→exist→search} pipeline.
\end{itemize}

\section{Reproducibility (runnable artifacts)}

\begin{itemize}
\item \textbf{Script:} \code{arc\_abstraction\_dsl\_2.py}
\item \textbf{Outputs:} \code{challenging\_metrics.txt}, \code{challenging\_metrics.json}
\end{itemize}

Run with \code{python3 arc\_abstraction\_dsl\_2.py}. The script prints a summary (``Challenging Single-Dataset Metrics'') and writes both artifacts in the working directory. The ``Local-run results'' above are taken from your updated run and reflected here.

\section{Takeaways}

Abstractions as \textbf{\code{G + invariant}}, composed as \textbf{A1→A2}, turn a symmetry-riddled search into an almost trivial one for the studied ARC family. The composition removes palette and enumeration symmetries, yields a \textbf{two-program} search space in which \textbf{both} programs are valid, and delivers \textbf{×100+} speedups---all with simple, transparent rules.

\section*{Appendix: Glossary of terms}

\begin{itemize}
\item \textbf{ARC:} Abstraction and Reasoning Corpus; small integer-grid puzzles.
\item \textbf{Symmetry quotient:} Identifying states/programs that differ only by a symmetry (palette permutation, object ordering), keeping a single canonical representative.
\item \textbf{Invariant:} A condition that must hold after normalization (e.g., background \code{0} preserved).
\item \textbf{Gauge:} The bookkeeping needed to transfer an abstract action back to the original instance (palette map, canonical order list).
\item \textbf{Selector:} A rule that names a component (e.g., \code{index0}, \code{smallest}).
\item \textbf{Color rule:} A rule that names a palette color (e.g., \code{least\_frequent}).
\item \textbf{Recolor:} Action that applies the chosen color to the selected component.
\end{itemize}

\end{document}
